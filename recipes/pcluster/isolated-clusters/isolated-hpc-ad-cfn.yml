Description: Isolated Cluster with Active Directory Certificate Validation

Parameters:
  DomainName:
    Description: AD Domain Name.
    Type: String
    Default: corp.pcluster.com
    AllowedPattern: ^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+$
  AdminPassword:
    Description: AD Admin Password.
    Type: String
    MinLength: 8
    MaxLength: 64
    AllowedPattern: (?=^.{8,64}$)((?=.*\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[^A-Za-z0-9\s])(?=.*[a-z])|(?=.*[^A-Za-z0-9\s])(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9\s]))^.*
    NoEcho: true
  ReadOnlyPassword:
    Description: AD ReadOnlyUser Password.
    Type: String
    MinLength: 8
    MaxLength: 64
    AllowedPattern: (?=^.{8,64}$)((?=.*\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[^A-Za-z0-9\s])(?=.*[a-z])|(?=.*[^A-Za-z0-9\s])(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9\s]))^.*
    NoEcho: true
  UserName:
    Description: Cluster user that is created in the Active Directory.
    Type: String
    Default: user000
    MinLength: 3
    MaxLength: 64
  UserPassword:
    Description: Cluster user Password.
    Type: String
    MinLength: 8
    MaxLength: 64
    AllowedPattern: (?=^.{8,64}$)((?=.*\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[^A-Za-z0-9\s])(?=.*[a-z])|(?=.*[^A-Za-z0-9\s])(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9\s]))^.*
    NoEcho: true
  ClusterAdminName:
    Description: Cluster admin that is created in the Active Directory.
    Type: String
    Default: cluster-admin
    MinLength: 3
    MaxLength: 64
  ClusterAdminPassword:
    Description: Cluster admin Password.
    Type: String
    MinLength: 8
    MaxLength: 64
    AllowedPattern: (?=^.{8,64}$)((?=.*\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[^A-Za-z0-9\s])(?=.*[a-z])|(?=.*[^A-Za-z0-9\s])(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9\s]))^.*
    NoEcho: true
  S3BucketName:
    Description: S3 bucket that contains files for ParallelCluster
    Type: String

  EC2InstancesAmiId:
    Description: AMI for the AdDomainAdminNode
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64'
  Keypair:
    Description: EC2 Keypair to access AdDomainAdminNode
    Type: AWS::EC2::KeyPair::KeyName

  AllowedIPAddressAndCIDRforAdmins:
    Description: Enter the allowed IP address and CIDR block for Administrators
    Type: String
    Default: 0.0.0.0/0

  AllowedIPAddressAndCIDRforUsers:
    Description: Enter the allowed IP address and CIDR block for Users
    Type: String
    Default: 0.0.0.0/0

Transform: AWS::Serverless-2016-10-31

Conditions:
  CreateVPC: !Equals ['', '']
  CreateAD: !Equals ['', '']

Resources:
  DisableImdsv1LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateData:
        MetadataOptions:
          HttpEndpoint: enabled
          HttpPutResponseHopLimit: 4
          HttpTokens: required
  PclusterVpc:
    Type: 'AWS::EC2::VPC'
    Condition: CreateVPC
    Properties:
      CidrBlock: '10.0.0.0/16'
      EnableDnsSupport: 'true'
      EnableDnsHostnames: 'true'
      InstanceTenancy: 'default'
      Tags:
        - Key: Name
          Value: PclusterVpc

  IsolatedDHCP:
    Type: 'AWS::EC2::DHCPOptions'
    DependsOn: Prep
    Properties:
      DomainName: !Ref DomainName
      DomainNameServers: 
        - !GetAtt Prep.DnsIpAddress1
        - !GetAtt Prep.DnsIpAddress2        

  VPCDHCPOptionsAssociation:
    Type: 'AWS::EC2::VPCDHCPOptionsAssociation'
    DependsOn: Directory
    Properties:
      VpcId: !Ref PclusterVpc
      DhcpOptionsId: !Ref IsolatedDHCP
  
  IsolatedHPCSubnetOne:
    Type: 'AWS::EC2::Subnet'
    Condition: CreateVPC
    Properties:
      VpcId: !Ref PclusterVpc
      CidrBlock: '10.0.0.0/24'
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: 'false'
      Tags:
        - Key: Name
          Value: IsolatedHPCSubnetOne
          
  IsolatedHPCSubnetTwo:
    Type: 'AWS::EC2::Subnet'
    Condition: CreateVPC
    Properties:
      VpcId: !Ref PclusterVpc
      CidrBlock: '10.0.1.0/24'
      AvailabilityZone: !Select [1, !GetAZs '']
      MapPublicIpOnLaunch: 'false'
      Tags:
        - Key: Name
          Value: IsolatedHPCSubnetTwo

  ParallelClusterAdminNodeSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: 'Security group for ParallelCluster Admin Node EC2'
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          FromPort: -1
          IpProtocol: "-1"
          ToPort: -1
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Ref AllowedIPAddressAndCIDRforAdmins
      VpcId: !Ref PclusterVpc
      
  HeadNodeSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: 'Head node security group'
      VpcId: !Ref PclusterVpc

  ComputeNodeSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: 'Compute node security group'
      VpcId: !Ref PclusterVpc

  LoginNodeSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: 'Login node security group'
      VpcId: !Ref PclusterVpc 
  
  ComputeToHeadIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref HeadNodeSecurityGroup
      SourceSecurityGroupId: !Ref ComputeNodeSecurityGroup
      Description: 'Allow inbound traffic from compute nodes to head node'
      IpProtocol: '-1'

  ComputeToComputeIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref ComputeNodeSecurityGroup
      SourceSecurityGroupId: !Ref ComputeNodeSecurityGroup
      Description: 'Allow inbound traffic from compute nodes to compute nodes'
      IpProtocol: '-1'

  HeadToComputeIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref ComputeNodeSecurityGroup
      SourceSecurityGroupId: !Ref HeadNodeSecurityGroup
      Description: 'Allow inbound traffic from head node to compute nodes'
      IpProtocol: '-1'

  ComputetoLoginIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref LoginNodeSecurityGroup
      SourceSecurityGroupId: !Ref ComputeNodeSecurityGroup
      Description: 'Allow inbound traffic from login node to compute nodes'
      IpProtocol: '-1' 
  
  LoginToLoginIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref LoginNodeSecurityGroup
      SourceSecurityGroupId: !Ref LoginNodeSecurityGroup
      Description: 'Allow inbound traffic from compute nodes to compute nodes'
      IpProtocol: '-1'

  LoginToComputeIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref ComputeNodeSecurityGroup
      SourceSecurityGroupId: !Ref LoginNodeSecurityGroup
      Description: 'Allow inbound traffic from login nodes to compute nodes'
      IpProtocol: '-1'

  LoginToHeadIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref HeadNodeSecurityGroup
      SourceSecurityGroupId: !Ref LoginNodeSecurityGroup
      Description: 'Allow inbound traffic from login nodes to head node'
      IpProtocol: '-1'

  HeadToLoginIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref LoginNodeSecurityGroup
      SourceSecurityGroupId: !Ref HeadNodeSecurityGroup
      Description: 'Allow inbound traffic from head node to login nodes'
      IpProtocol: '-1'

  LoginEgress:
    Type: 'AWS::EC2::SecurityGroupEgress'
    Properties:
      GroupId: !Ref LoginNodeSecurityGroup
      CidrIp: 0.0.0.0/0
      Description: 'Allow all outbound traffic from login nodes'
      IpProtocol: '-1'  

  SSHtoLogin:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref LoginNodeSecurityGroup
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      CidrIp: !Ref AllowedIPAddressAndCIDRforUsers

  HeadToAdminIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref HeadNodeSecurityGroup
      SourceSecurityGroupId: !Ref ParallelClusterAdminNodeSecurityGroup
      Description: 'Allow inbound traffic from admin node to head node'
      IpProtocol: '-1'

  AllowAllEgress:
    Type: 'AWS::EC2::SecurityGroupEgress'
    Properties:
      GroupId: !Ref ComputeNodeSecurityGroup
      CidrIp: 0.0.0.0/0
      Description: 'Allow all outbound traffic from compute nodes'
      IpProtocol: '-1'  

  VpcEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow SSM access
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          FromPort: -1
          IpProtocol: "-1"
          ToPort: -1
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          FromPort: 443
          IpProtocol: tcp
          ToPort: 443
      VpcId: !Ref PclusterVpc 

  CloudWatchLogsEndpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    DependsOn: NetworkLoadBalancer
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.logs'
      VpcEndpointType: 'Interface'
      SecurityGroupIds: 
        - !GetAtt VpcEndpointSecurityGroup.GroupId      
      SubnetIds:
        - !Ref IsolatedHPCSubnetTwo
      PrivateDnsEnabled: true
      
  CloudWatchMonitoringEndpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    DependsOn: NetworkLoadBalancer
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.monitoring'
      VpcEndpointType: 'Interface'
      SecurityGroupIds: 
        - !GetAtt VpcEndpointSecurityGroup.GroupId      
      SubnetIds:
        - !Ref IsolatedHPCSubnetTwo
      PrivateDnsEnabled: true

  CloudFormationEndpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    DependsOn: NetworkLoadBalancer
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.cloudformation'
      VpcEndpointType: 'Interface'
      SecurityGroupIds: 
        - !GetAtt VpcEndpointSecurityGroup.GroupId 
      SubnetIds:
        - !Ref IsolatedHPCSubnetTwo
      PrivateDnsEnabled: true
   
  STSEndpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    DependsOn: NetworkLoadBalancer
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.sts'
      VpcEndpointType: 'Interface'
      SecurityGroupIds: 
        - !GetAtt VpcEndpointSecurityGroup.GroupId      
      SubnetIds:
        - !Ref IsolatedHPCSubnetTwo
      PrivateDnsEnabled: true
        
  EC2Endpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    DependsOn: NetworkLoadBalancer
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ec2'
      VpcEndpointType: 'Interface'
      SecurityGroupIds: 
        - !GetAtt VpcEndpointSecurityGroup.GroupId
      SubnetIds:
        - !Ref IsolatedHPCSubnetTwo
      PrivateDnsEnabled: true
        
  S3Endpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.s3'
      VpcEndpointType: 'Gateway'
      RouteTableIds:
        - !Ref PrivateRouteTable
        
  DynamoDBEndpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.dynamodb'
      VpcEndpointType: 'Gateway'
      RouteTableIds:
        - !Ref PrivateRouteTable
        
  SystemsManagerEndpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    DependsOn: NetworkLoadBalancer
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ssm'
      VpcEndpointType: 'Interface'
      SecurityGroupIds: 
        - !GetAtt VpcEndpointSecurityGroup.GroupId      
      SubnetIds:
        - !Ref IsolatedHPCSubnetTwo
      PrivateDnsEnabled: true
        
  SSMMessagesEndpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    DependsOn: NetworkLoadBalancer
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ssmmessages'
      VpcEndpointType: 'Interface'
      SecurityGroupIds: 
        - !GetAtt VpcEndpointSecurityGroup.GroupId      
      SubnetIds:
        - !Ref IsolatedHPCSubnetTwo
      PrivateDnsEnabled: true
        
  SecretsManagerEndpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    DependsOn: NetworkLoadBalancer
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.secretsmanager'
      VpcEndpointType: 'Interface'
      SecurityGroupIds: 
        - !GetAtt VpcEndpointSecurityGroup.GroupId  
      SubnetIds:
        - !Ref IsolatedHPCSubnetTwo
      PrivateDnsEnabled: true
        
  AutoscalingEndpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    DependsOn: NetworkLoadBalancer
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.autoscaling'
      VpcEndpointType: 'Interface'
      SecurityGroupIds: 
        - !GetAtt VpcEndpointSecurityGroup.GroupId      
      SubnetIds:
        - !Ref IsolatedHPCSubnetTwo
      PrivateDnsEnabled: true  

  EC2MessagesEndpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Condition: CreateVPC
    DependsOn: NetworkLoadBalancer
    Properties:
      VpcId: !Ref PclusterVpc
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ec2messages'
      VpcEndpointType: 'Interface'
      SecurityGroupIds: 
        - !GetAtt VpcEndpointSecurityGroup.GroupId      
      SubnetIds:
        - !Ref IsolatedHPCSubnetTwo
      PrivateDnsEnabled: true
        
  PrivateRouteTable:
    Type: 'AWS::EC2::RouteTable'
    Condition: CreateVPC
    Properties:
      VpcId: !Ref PclusterVpc

  SubnetARouteTableAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    Condition: CreateVPC
    Properties:
      SubnetId: !Ref IsolatedHPCSubnetOne
      RouteTableId: !Ref PrivateRouteTable
  
  SubnetBRouteTableAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    Condition: CreateVPC
    Properties:
      SubnetId: !Ref IsolatedHPCSubnetTwo
      RouteTableId: !Ref PrivateRouteTable
  
  AdDomainAdminNodeRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/AmazonSSMDirectoryServiceAccess
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ds:ResetUserPassword
                Effect: Allow
                Resource: !Sub
                    - arn:${AWS::Partition}:ds:${AWS::Region}:${AWS::AccountId}:directory/${DirectoryId}
                    # - { DirectoryId: !If [CreateAD, !Ref Directory, !Ref Ad ] }
                    - { DirectoryId: !Ref Directory }
          PolicyName: ResetUserPassword
        - PolicyDocument:
            Statement:
              - Action:
                  - secretsmanager:PutSecretValue
                Effect: Allow
                Resource:
                  - !Ref DomainCertificateSecret
                  - !Ref DomainPrivateKeySecret
          PolicyName: PutDomainCertificateSecrets          
        - PolicyDocument:
            Statement:
              - Action:
                  - s3:ListBucket
                  - s3:GetObject
                  - s3:PutObject
                Effect: Allow
                Resource:
                  - !Sub 'arn:${AWS::Partition}:s3:::${S3BucketName}'
                  - !Sub 'arn:${AWS::Partition}:s3:::${S3BucketName}/*'
          PolicyName: S3Access

  S3AccessPolicy:
    Type: 'AWS::IAM::Policy'
    Properties:
      PolicyName: 'S3AccessPolicy'
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Action:
              - 's3:GetObject'
              - 's3:ListBucket'
            Resource:
              - !Sub 'arn:${AWS::Partition}:s3:::${S3BucketName}'
              - !Sub 'arn:${AWS::Partition}:s3:::${S3BucketName}/*'
      Roles:
        - !Ref ParallelClusterComputeLoginRole
        
  ParallelClusterComputeLoginRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - 'ec2.amazonaws.com'
            Action:
              - 'sts:AssumeRole'
      Path: '/'

  ParallelClusterAdminNodeRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      Path: "/"
      Policies:
        - PolicyName: CustomParallelClusterPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: 'EC2Read'
                Effect: Allow
                Action: 
                    - 'ec2:Describe*'
                Resource: '*'
              - Sid: 'EC2Write'
                Effect: Allow
                Action: 
                    - 'ec2:AllocateAddress'
                    - 'ec2:AssociateAddress'
                    - 'ec2:AttachNetworkInterface'
                    - 'ec2:AuthorizeSecurityGroupEgress'
                    - 'ec2:AuthorizeSecurityGroupIngress'
                    - 'ec2:CreateFleet'
                    - 'ec2:CreateLaunchTemplate'
                    - 'ec2:CreateLaunchTemplateVersion'
                    - 'ec2:CreateNetworkInterface'
                    - 'ec2:CreatePlacementGroup'
                    - 'ec2:CreateSecurityGroup'
                    - 'ec2:CreateSnapshot'
                    - 'ec2:CreateTags'
                    - 'ec2:CreateVolume'
                    - 'ec2:DeleteLaunchTemplate'
                    - 'ec2:DeleteNetworkInterface'
                    - 'ec2:DeletePlacementGroup'
                    - 'ec2:DeleteSecurityGroup'
                    - 'ec2:DeleteVolume'
                    - 'ec2:DisassociateAddress'
                    - 'ec2:ModifyLaunchTemplate'
                    - 'ec2:ModifyNetworkInterfaceAttribute'
                    - 'ec2:ModifyVolume'
                    - 'ec2:ModifyVolumeAttribute'
                    - 'ec2:ReleaseAddress'
                    - 'ec2:RevokeSecurityGroupEgress'
                    - 'ec2:RevokeSecurityGroupIngress'
                    - 'ec2:RunInstances'
                    - 'ec2:TerminateInstances'
                Resource: '*'
              - Sid: 'DynamoDB'
                Effect: Allow
                Action: 
                    - 'dynamodb:DescribeTable'
                    - 'dynamodb:ListTagsOfResource'
                    - 'dynamodb:CreateTable'
                    - 'dynamodb:DeleteTable'
                    - 'dynamodb:GetItem'
                    - 'dynamodb:PutItem'
                    - 'dynamodb:UpdateItem'
                    - 'dynamodb:Query'
                    - 'dynamodb:TagResource'
                Resource: !Sub 'arn:${AWS::Partition}:dynamodb:*:${AWS::AccountId}:table/parallelcluster-*'
              - Sid: 'Route53HostedZones'
                Effect: Allow
                Action: 
                    - 'route53:ChangeResourceRecordSets'
                    - 'route53:ChangeTagsForResource'
                    - 'route53:CreateHostedZone'
                    - 'route53:DeleteHostedZone'
                    - 'route53:GetChange'
                    - 'route53:GetHostedZone'
                    - 'route53:ListResourceRecordSets'
                    - 'route53:ListQueryLoggingConfigs'
                Resource: '*'
              - Sid: 'CloudWatch'
                Effect: Allow
                Action: 
                    - 'cloudwatch:PutDashboard'
                    - 'cloudwatch:ListDashboards'
                    - 'cloudwatch:DeleteDashboards'
                    - 'cloudwatch:GetDashboard'
                    - 'cloudwatch:PutMetricAlarm'
                    - 'cloudwatch:DeleteAlarms'
                    - 'cloudwatch:DescribeAlarms'
                    - 'cloudwatch:PutCompositeAlarm'
                Resource: '*'
              - Sid: 'IamRead'
                Effect: Allow
                Action: 
                    - 'iam:GetRole'
                    - 'iam:GetRolePolicy'
                    - 'iam:GetPolicy'
                    - 'iam:SimulatePrincipalPolicy'
                    - 'iam:GetInstanceProfile'
                Resource:
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/*'
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/*'
                    - !Sub 'arn:${AWS::Partition}:iam::aws:policy/*'
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/*'
              - Sid: 'CloudFormation'
                Effect: Allow
                Action: 
                    - 'cloudformation:*'
                Resource: '*' 
              - Sid: 'IamInstanceProfile'
                Effect: Allow
                Action: 
                    - 'iam:CreateInstanceProfile'
                    - 'iam:DeleteInstanceProfile'
                    - 'iam:AddRoleToInstanceProfile'
                    - 'iam:RemoveRoleFromInstanceProfile'
                Resource: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/parallelcluster/*'
              - Sid: 'IamPassRole'
                Effect: Allow
                Action: 
                    - 'iam:PassRole'
                Resource: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*'
                Condition: 
                  StringEqualsIfExists:
                    "iam:PassedToService":
                      - "lambda.amazonaws.com"
                      - "ec2.amazonaws.com"
                      - "spotfleet.amazonaws.com"
              - Sid: 'Lambda'
                Effect: Allow
                Action: 
                    - 'lambda:CreateFunction'
                    - 'lambda:DeleteFunction'
                    - 'lambda:GetFunctionConfiguration'
                    - 'lambda:GetFunction'
                    - 'lambda:InvokeFunction'
                    - 'lambda:AddPermission'
                    - 'lambda:RemovePermission'
                    - 'lambda:UpdateFunctionConfiguration'
                    - 'lambda:TagResource'
                    - 'lambda:ListTags'
                    - 'lambda:UntagResource'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:lambda:*:${AWS::AccountId}:function:parallelcluster-*'
                    - !Sub 'arn:${AWS::Partition}:lambda:*:${AWS::AccountId}:function:pcluster-*'
              - Sid: 'S3ResourcesBucket'
                Effect: Allow
                Action: 
                    - 's3:*'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:s3:::${S3BucketName}*'
                    - !Sub 'arn:${AWS::Partition}:s3:::${S3BucketName}/*'
                    - !Sub 'arn:${AWS::Partition}:s3:::parallelcluster-*'
                    - !Sub 'arn:${AWS::Partition}:s3:::aws-parallelcluster-*'
                    - !Sub 'arn:${AWS::Partition}:s3:::parallelcluster-*/*' 
              - Sid: 'S3ParallelClusterReadOnly'
                Effect: Allow
                Action: 
                    - 's3:Get*'
                    - 's3:List*'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:s3:::*-aws-parallelcluster*'
              - Sid: 'EFS'
                Effect: Allow
                Action: 
                    - 'elasticfilesystem:*'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:elasticfilesystem:*:${AWS::AccountId}:*'
              - Sid: 'CloudWatchLogs'
                Effect: Allow
                Action: 
                    - 'logs:DeleteLogGroup'
                    - 'logs:PutRetentionPolicy'
                    - 'logs:DescribeLogGroups'
                    - 'logs:CreateLogGroup'
                    - 'logs:TagResource'
                    - 'logs:UntagResource'
                    - 'logs:FilterLogEvents'
                    - 'logs:GetLogEvents'
                    - 'logs:CreateExportTask'
                    - 'logs:DescribeLogStreams'
                    - 'logs:DescribeExportTasks'
                    - 'logs:DescribeMetricFilters'
                    - 'logs:PutMetricFilter'
                    - 'logs:DeleteMetricFilter'
                Resource: 
                    - '*'
              - Sid: 'ResourceGroupRead'
                Effect: Allow
                Action: 
                    - 'resource-groups:ListGroupResources'
                Resource: 
                    - '*'
              - Sid: 'AllowDescribingFileCache'
                Effect: Allow
                Action: 
                    - 'fsx:DescribeFileCaches'
                Resource: 
                    - '*'
              - Sid: 'DescribeSecret'
                Effect: Allow
                Action: 
                    - 'secretsmanager:DescribeSecret'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${PasswordSecret}' 
              - Sid: 'FSx'
                Effect: Allow
                Action: 
                    - 'fsx:*'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:fsx:*:${AWS::AccountId}:*'
              - Sid: 'FSxServiceRole'
                Effect: Allow
                Action: 
                    - 'iam:CreateServiceLinkedRole'
                    - 'iam:DeleteServiceLinkedRole'
                Resource: 
                    - '*'
                Condition: 
                  StringEquals:
                    "iam:AWSServiceName":
                      - 'fsx.amazonaws.com'
                      - 's3.data-source.lustre.fsx.amazonaws.com'
              - Sid: 'FSxAttachRole'
                Effect: Allow
                Action: 
                    - 'iam:CreateServiceLinkedRole'
                    - 'iam:AttachRolePolicy'
                    - 'iam:PutRolePolicy'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/aws-service-role/s3.data-source.lustre.fsx.amazonaws.com/*'
              - Sid: 'EC2'
                Effect: Allow
                Action: 
                    - 'ec2:DescribeImages'
                    - 'ec2:DescribeInstanceTypeOfferings'
                    - 'ec2:DescribeInstanceTypes'
                    - 'ec2:DeregisterImage'
                    - 'ec2:DeleteSnapshot'
                Resource: 
                    - '*'  
              - Sid: 'IAM'
                Effect: Allow
                Action: 
                    - 'iam:CreateInstanceProfile'
                    - 'iam:AddRoleToInstanceProfile'
                    - 'iam:GetRole'
                    - 'iam:GetRolePolicy'
                    - 'iam:GetInstanceProfile'
                    - 'iam:RemoveRoleFromInstanceProfile'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/parallelcluster/*'
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/ParallelClusterImage*'
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*'
              - Sid: 'IAMPassRole'
                Effect: Allow
                Action: 
                    - 'iam:PassRole'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/parallelcluster/*'
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*'
                Condition: 
                  StringEquals:
                    "iam:PassedToService":
                      - 'lambda.amazonaws.com'
                      - 'ec2.amazonaws.com'
              - Sid: 'CloudWatchIB'
                Effect: Allow
                Action: 
                    - 'logs:CreateLogGroup'
                    - 'logs:TagResource'
                    - 'logs:UntagResource'
                    - 'logs:DeleteLogGroup'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:logs:*:${AWS::AccountId}:log-group:/aws/imagebuilder/ParallelClusterImage-*'
                    - !Sub 'arn:${AWS::Partition}:logs:*:${AWS::AccountId}:log-group:/aws/lambda/ParallelClusterImage-*'
              - Sid: 'CloudFormationIB'
                Effect: Allow
                Action: 
                    - 'cloudformation:DescribeStacks'
                    - 'cloudformation:CreateStack'
                    - 'cloudformation:DeleteStack'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:cloudformation:*:${AWS::AccountId}:stack/*'
              - Sid: 'LambdaIB'
                Effect: Allow
                Action: 
                    - 'lambda:CreateFunction'
                    - 'lambda:GetFunction'
                    - 'lambda:AddPermission'
                    - 'lambda:RemovePermission'
                    - 'lambda:DeleteFunction'
                    - 'lambda:TagResource'   
                    - 'lambda:ListTags'
                    - 'lambda:UntagResource'                        
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:lambda:*:${AWS::AccountId}:function:ParallelClusterImage-*'
              - Sid: 'ImageBuilderGet'
                Effect: Allow
                Action: 
                    - 'imagebuilder:Get*'
                Resource: 
                    - '*'
              - Sid: 'ImageBuilder'
                Effect: Allow
                Action: 
                    - 'imagebuilder:CreateImage'
                    - 'imagebuilder:TagResource'
                    - 'imagebuilder:CreateImageRecipe'
                    - 'imagebuilder:CreateComponent'
                    - 'imagebuilder:CreateDistributionConfiguration'
                    - 'imagebuilder:CreateInfrastructureConfiguration' 
                    - 'imagebuilder:DeleteImage'
                    - 'imagebuilder:DeleteComponent'
                    - 'imagebuilder:DeleteImageRecipe'    
                    - 'imagebuilder:DeleteInfrastructureConfiguration'
                    - 'imagebuilder:DeleteDistributionConfiguration'                      
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:imagebuilder:*:${AWS::AccountId}:image/parallelclusterimage-*'
                    - !Sub 'arn:${AWS::Partition}:imagebuilder:*:${AWS::AccountId}:image-recipe/parallelclusterimage-*'
                    - !Sub 'arn:${AWS::Partition}:imagebuilder:*:${AWS::AccountId}:component/parallelclusterimage-*'
                    - !Sub 'arn:${AWS::Partition}:imagebuilder:*:${AWS::AccountId}:distribution-configuration/parallelclusterimage-*'
                    - !Sub 'arn:${AWS::Partition}:imagebuilder:*:${AWS::AccountId}:infrastructure-configuration/parallelclusterimage-*'
              - Sid: 'SNS'
                Effect: Allow
                Action: 
                    - 'sns:GetTopicAttributes'
                    - 'sns:TagResource'
                    - 'sns:CreateTopic'
                    - 'sns:Subscribe'
                    - 'sns:Publish'
                    - 'sns:DeleteTopic'
                    - 'sns:Unsubscribe'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:sns:*:${AWS::AccountId}:ParallelClusterImage-*'
              - Sid: 'CreateServiceLinkedRole'
                Effect: Allow
                Action: 
                    - 'iam:CreateServiceLinkedRole'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:iam::*:role/aws-service-role/imagebuilder.amazonaws.com/AWSServiceRoleForImageBuilder'
                Condition: 
                  StringLike:
                    "iam:AWSServiceName":
                      - 'imagebuilder.amazonaws.com'
              - Sid: 'IamRole'
                Effect: Allow
                Action: 
                    - 'iam:CreateServiceLinkedRole'
                    - 'iam:DeleteRole'
                    - 'iam:TagRole'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*'
              - Sid: 'IamCreateRole'
                Effect: Allow
                Action: 
                    - 'iam:CreateRole'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*' 
              - Sid: 'IamInlinePolicy'
                Effect: Allow
                Action: 
                    - 'iam:DeleteRolePolicy'
                    - 'iam:PutRolePolicy'
                Resource: 
                    - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*'
              - Sid: 'IamPolicy'
                Effect: Allow
                Action: 
                    - 'iam:AttachRolePolicy'
                    - 'iam:DetachRolePolicy'
                Resource: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*'
                Condition: 
                  ArnLike:
                    "iam:PolicyARN":
                      - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/parallelcluster*'
                      - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/parallelcluster/*'
                      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/CloudWatchAgentServerPolicy'
                      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore'
                      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/AWSBatchFullAccess'
                      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/AmazonS3ReadOnlyAccess'
                      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSBatchServiceRole'
                      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role'
                      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy'
                      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AmazonEC2SpotFleetTaggingRole'
                      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/EC2InstanceProfileForImageBuilder'
                      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
                      - !Sub '${DomainCertificateSecretReadPolicy}'
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore'
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/ElasticLoadBalancingFullAccess'
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/AutoScalingFullAccess'
  
  AdDomainProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - Ref: AdDomainAdminNodeRole  
 
  PclusterProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - Ref: ParallelClusterAdminNodeRole
        
  PrepRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      Policies:
        - PolicyName: LogOutput
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                - logs:CreateLogGroup
                - logs:CreateLogStream
                - logs:PutLogEvents
                Effect: Allow
                # Resource: !Sub arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-Prep:*
                Resource: '*'
        - PolicyName: DescribeDirectory
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ds:DescribeDirectories
                # Resource: !Sub arn:${AWS::Partition}:ds:*:${AWS::AccountId}:directory/*
                Resource: '*'

  PrepLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: !Sub "${AWS::StackName}: custom resource handler to prepare the stack."
      Handler: index.handler
      MemorySize: 128
      Role: !GetAtt PrepRole.Arn
      Runtime: python3.9
      Timeout: 300
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          import time
          import cfnresponse
          import boto3
          import logging
          import random
          import string
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          ec2 = boto3.client("ec2")
          ds = boto3.client("ds")

          def create_physical_resource_id():
              alnum = string.ascii_uppercase + string.ascii_lowercase + string.digits
              return ''.join(random.choice(alnum) for _ in range(16))

          def handler(event, context):
              print(event)
              print( 'boto version {}'.format(boto3.__version__))
              domain = event['ResourceProperties']['DomainName']
              vpc_id = event['ResourceProperties']['Vpc']
              directory_id = event['ResourceProperties']['DirectoryId']
              subnet1_id = event['ResourceProperties']['IsolatedHPCSubnetOne']
              subnet2_id = event['ResourceProperties']['IsolatedHPCSubnetTwo']

              directory = ds.describe_directories(DirectoryIds=[directory_id])['DirectoryDescriptions'][0]
              dns_ip_addrs = directory['DnsIpAddrs']

              response_data = {}
              reason = None
              response_status = cfnresponse.SUCCESS
              stack_id_suffix = event['StackId'].split("/")[1]

              if event['RequestType'] == 'Create':
                  response_data['Message'] = 'Resource creation successful!'
                  physical_resource_id = create_physical_resource_id()

                  # provide outputs
                  response_data['DomainName'] = domain
                  response_data['DomainShortName'] = domain.split(".")[0].upper()
                  response_data['VpcId'] = vpc_id
                  response_data['Subnet1Id'] = subnet1_id
                  response_data['Subnet2Id'] = subnet2_id
                  response_data['DnsIpAddresses'] = dns_ip_addrs
                  for i, addr in enumerate(dns_ip_addrs):
                    addr_index = i + 1
                    response_data[f'DnsIpAddress{addr_index}'] = addr
              else:
                  physical_resource_id = event['PhysicalResourceId']
              cfnresponse.send(event, context, response_status, response_data, physical_resource_id, reason)

  Directory:
    Type: AWS::DirectoryService::MicrosoftAD
    Condition: CreateAD
    DependsOn: NetworkLoadBalancer
    Properties:
      Name: !Ref DomainName
      Password: !Ref AdminPassword
      Edition: Standard
      VpcSettings:
        SubnetIds:
          - !Ref IsolatedHPCSubnetOne
          - !Ref IsolatedHPCSubnetTwo
        VpcId: !Ref PclusterVpc

  Prep:
    Type: Custom::PrepLambda
    Properties:
      ServiceToken: !GetAtt PrepLambda.Arn
      DomainName:  !Ref DomainName
      Vpc: !Ref PclusterVpc
      IsolatedHPCSubnetOne: !Ref IsolatedHPCSubnetOne
      IsolatedHPCSubnetTwo: !Ref IsolatedHPCSubnetTwo
      DirectoryId: !Ref Directory

  AdDomainAdminNode:
    Type: 'AWS::EC2::Instance' 
    DependsOn: Directory
    Properties:
      InstanceType: t2.micro
      KeyName: !Ref Keypair
      LaunchTemplate:
        LaunchTemplateId: !Ref 'DisableImdsv1LaunchTemplate'
        Version: !GetAtt 'DisableImdsv1LaunchTemplate.LatestVersionNumber'      
      ImageId: !Ref EC2InstancesAmiId
      SecurityGroupIds: [!Ref ParallelClusterAdminNodeSecurityGroup]
      SubnetId: !Ref IsolatedHPCSubnetTwo
      IamInstanceProfile: !Ref AdDomainProfile
      Tags:
        - Key: Name
          Value: AdDomainAdminNode
      UserData:
        Fn::Base64: 
          !Sub
            - |        
              #!/bin/bash
              mkdir /usr/bin/directory
              cd /usr/bin/directory
              aws s3 cp s3://${S3BucketName} . --recursive --exclude "*" --include "*.rpm"
              rpm -ivh *.rpm
              sleep 15
              exec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1
              echo "Domain Name: ${DirectoryDomain}"
              echo "Domain Certificate Secret: ${DomainCertificateSecretArn}"
              echo "Domain Private Key Secret: ${DomainPrivateKeySecretArn}"
              cat << EOF > /etc/resolv.conf
              search           ${DirectoryDomain}
              nameserver       ${DnsIp1}
              nameserver       ${DnsIp2}
              EOF

              sed -i 's/PEERDNS=.*/PEERDNS=no/' /etc/sysconfig/network-scripts/ifcfg-eth0
              chattr +i /run/systemd/resolve/resolv.conf
              cat << 'EOF' > dns.sh
              #!/bin/bash

              NAMESERVER1="${DnsIp1}"
              NAMESERVER2="${DnsIp2}"
              SEARCH_DOMAIN="${DirectoryDomain}"

              cat <<EOL > /etc/resolv.conf
              nameserver $NAMESERVER1
              nameserver $NAMESERVER2
              search $SEARCH_DOMAIN
              EOF
              chmod +x dns.sh
              aws s3 cp /usr/bin/directory/dns.sh s3://${S3BucketName}/dns.sh --region "${AWS::Region}"
              cat << 'EOF' > hosts.sh
              #!/bin/bash
              cat <<EOL > /etc/hosts
              10.0.0.100 corp.pcluster.com
              10.0.1.100 corp.pcluster.com
              EOF
              chmod +x hosts.sh
              aws s3 cp /usr/bin/directory/hosts.sh s3://${S3BucketName}/hosts.sh --region "${AWS::Region}"
              ADMIN_PW="${AdminPassword}"
              echo "$ADMIN_PW" | sudo realm join -U Admin "${DirectoryDomain}"
              sleep 10
              echo "Creating Admin Group..."
              echo "$ADMIN_PW" | adcli create-group "cluster-admins" -x -U Admin --domain="${DirectoryDomain}" 
              sleep 2
              echo "Creating User Group..."
              echo "$ADMIN_PW" | adcli create-group "cluster-users" -x -U Admin --domain="${DirectoryDomain}" 
              sleep 2
              echo "Registering Cluster Admin..."
              echo "$ADMIN_PW" | adcli create-user -x -U Admin --domain="${DirectoryDomain}" --display-name="${ClusterAdminName}" "${ClusterAdminName}"
              sleep 2
              echo "Registering ReadOnlyUser..."
              echo "$ADMIN_PW" | adcli create-user -x -U Admin --domain="${DirectoryDomain}" --display-name=ReadOnlyUser ReadOnlyUser
              sleep 2
              echo "Registering User..."
              echo "$ADMIN_PW" | adcli create-user -x -U Admin --domain="${DirectoryDomain}" --display-name="${UserName}" "${UserName}"
              sleep 10
              echo "Adding Admin to Admin Group..."
              echo "$ADMIN_PW" | adcli add-member "cluster-admins" -x -U Admin "${ClusterAdminName}" --domain "${DirectoryDomain}"
              sleep 10
              echo "Adding User to User Group..."
              echo "$ADMIN_PW" | adcli add-member "cluster-users" -x -U Admin "${UserName}" --domain "${DirectoryDomain}"               
              
              echo "Creating domain certificate..."
              PRIVATE_KEY="${DirectoryDomain}.key"
              CERTIFICATE="${DirectoryDomain}.crt"
              printf '.\n.\n.\n.\n.\n%s\n.\n' "${DirectoryDomain}" | openssl req -x509 -sha256 -nodes -newkey rsa:2048 -keyout "$PRIVATE_KEY" -days 365 -out "$CERTIFICATE"

              echo "Storing domain private key to Secrets Manager..."
              aws secretsmanager put-secret-value --secret-id "${DomainPrivateKeySecretArn}" --secret-string "file://$PRIVATE_KEY" --region "${AWS::Region}"

              echo "Storing domain certificate to Secrets Manager..."
              aws secretsmanager put-secret-value --secret-id "${DomainCertificateSecretArn}" --secret-string "file://$CERTIFICATE" --region "${AWS::Region}"

              echo "Deleting private key and certificate from local file system..."
              rm -rf "$PRIVATE_KEY" "$CERTIFICATE"            
              
            - { DirectoryDomain: !GetAtt Prep.DomainName,
                AdminPassword: !Ref AdminPassword,
                UserName: !Ref UserName,
                DnsIp1: !GetAtt Prep.DnsIpAddress1,
                DnsIp2: !GetAtt Prep.DnsIpAddress2,
                DomainCertificateSecretArn: !Ref DomainCertificateSecret,
                DomainPrivateKeySecretArn: !Ref DomainPrivateKeySecret,
            } 
              
  ParallelClusterAdminNode:
    Type: 'AWS::EC2::Instance'
    DependsOn: NetworkLoadBalancerListener
    Properties:
      InstanceType: t2.micro
      KeyName: !Ref Keypair
      LaunchTemplate:
        LaunchTemplateId: !Ref 'DisableImdsv1LaunchTemplate'
        Version: !GetAtt 'DisableImdsv1LaunchTemplate.LatestVersionNumber'      
      ImageId: !Ref EC2InstancesAmiId
      SecurityGroupIds: [!Ref ParallelClusterAdminNodeSecurityGroup]
      SubnetId: !Ref IsolatedHPCSubnetTwo
      IamInstanceProfile: !Ref PclusterProfile
      Tags:
        - Key: Name
          Value: ParallelClusterAdminNode
      UserData:
        Fn::Base64: !Sub |
              #!/bin/bash
              mkdir /usr/bin/pcluster
              cd /usr/bin/pcluster
              cat << 'EOF' > IsolatedClusterWithAD.yaml
              Region: ${AWS::Region}
              Image:
                Os: alinux2
              HeadNode:
                InstanceType: t2.micro
                Networking:
                  SubnetId: ${IsolatedHPCSubnetTwo}
                  SecurityGroups: 
                    - ${HeadNodeSecurityGroup}
                Ssh:
                  KeyName: ${Keypair}
                Iam:
                  AdditionalIamPolicies:
                    - Policy: ${DomainCertificateSecretReadPolicy}
                    - Policy: arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
                  S3Access:
                    - BucketName: ${S3BucketName}
                      EnableWriteAccess: false
                      KeyName: active-directory.head.post.sh
                    - BucketName: ${S3BucketName}
                      EnableWriteAccess: false
                      KeyName: restrict-access.sh
                    - BucketName: ${S3BucketName}
                      EnableWriteAccess: false
                      KeyName: pam.sh
                    - BucketName: ${S3BucketName}
                      EnableWriteAccess: false
                      KeyName: dns.sh 
                    - BucketName: ${S3BucketName}
                      EnableWriteAccess: false
                      KeyName: hosts.sh   
                CustomActions:
                  OnNodeConfigured:
                    Sequence:
                      - Script: s3://${S3BucketName}/active-directory.head.post.sh
                        Args:
                          - ${DomainCertificateSecret}
                          - /opt/parallelcluster/shared/directory_service/domain-certificate.crt
                      - Script: s3://${S3BucketName}/restrict-access.sh
                      - Script: s3://${S3BucketName}/pam.sh
                      - Script: s3://${S3BucketName}/dns.sh
                      - Script: s3://${S3BucketName}/hosts.sh                      
              SharedStorage:
                - MountDir: /ebs
                  Name: EBSExtData
                  StorageType: Ebs
                  EbsSettings:
                    VolumeType: io1
                    DeletionPolicy: Delete
              LoginNodes:
                Pools:
                  - Name: user-pool
                    Count: 2
                    InstanceType: t2.micro
                    Ssh:
                      KeyName: ${Keypair}
                    Networking:
                      SubnetIds:
                        - ${IsolatedHPCSubnetTwo}
                      SecurityGroups:
                        - ${LoginNodeSecurityGroup}
                    Iam: 
                      AdditionalIamPolicies: 
                        - Policy: arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
              Scheduling:
                Scheduler: slurm
                SlurmSettings:
                  QueueUpdateStrategy: DRAIN
                  Dns:
                    DisableManagedDns: true
                    UseEc2Hostnames: true
                SlurmQueues:
                - Name: queue1
                  ComputeResources:
                  - Name: compute
                    Instances:
                    - InstanceType: t2.micro
                    MinCount: 1
                    MaxCount: 10
                  Networking:
                    SubnetIds:
                    - ${IsolatedHPCSubnetTwo}
                    SecurityGroups: 
                    - ${ComputeNodeSecurityGroup}
                  Iam:
                    AdditionalIamPolicies:
                      - Policy: arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
                      - Policy: arn:${AWS::Partition}:iam::aws:policy/AmazonS3ReadOnlyAccess
                  CustomActions:
                    OnNodeConfigured:
                      Sequence:
                        - Script: s3://${S3BucketName}/dns.sh
                        - Script: s3://${S3BucketName}/hosts.sh 
              DirectoryService:
                DomainName: ${DomainName} 
                DomainAddr: ldaps://${DomainName}
                PasswordSecretArn: ${PasswordSecret}
                DomainReadOnlyUser: cn=ReadOnlyUser,ou=Users,ou=CORP,dc=corp,dc=pcluster,dc=com 
                LdapTlsCaCert: /opt/parallelcluster/shared/directory_service/domain-certificate.crt
                LdapTlsReqCert: hard
              EOF
              cd /usr/bin/pcluster
              export AWS_DEFAULT_REGION=${AWS::Region}
              cat << 'EOF' > active-directory.head.post.sh
              #!/bin/bash

              CERTIFICATE_SECRET_ARN="$1"
              CERTIFICATE_PATH="$2"

              source /etc/parallelcluster/cfnconfig
              REGION="${AWS::Region}"

              mkdir -p $(dirname $CERTIFICATE_PATH)
              aws secretsmanager get-secret-value --region $REGION --secret-id $CERTIFICATE_SECRET_ARN --query SecretString --output text > $CERTIFICATE_PATH
              EOF
              cd /usr/bin/pcluster
              chmod +x active-directory.head.post.sh
              export PATH=/usr/bin/pcluster/pcluster-installer-bundle:/usr/bin/pcluster/pcluster-installer-bundle/node-v*/bin:/bin:PATH
              export AWS_DEFAULT_REGION=${AWS::Region}
              EOF
              aws s3 cp active-directory.head.post.sh s3://${S3BucketName}/active-directory.head.post.sh --region "${AWS::Region}"
              aws s3 cp s3://${S3BucketName}/dns.sh /usr/bin/pcluster
              chmod +x dns.sh
              ./dns.sh
              sed -i 's/PEERDNS=.*/PEERDNS=no/' /etc/sysconfig/network-scripts/ifcfg-eth0
              chattr +i /run/systemd/resolve/resolv.conf
              cd /usr/bin/pcluster
              aws s3 cp s3://${S3BucketName} /usr/bin/pcluster --recursive --exclude "*" --include "*.zip"
              sudo unzip *.zip -d pcluster-installer-bundle
              cat << 'EOF' > restrict-access.sh
              #!/bin/bash
              cat <<EOF > /etc/security/access.conf
              #note that this does not include the username for Ubuntu instances which is 'ubuntu'
              #this file restricts access to the following users or AD groups to the head node and blocks all others
              + : root : ALL
              + : ec2-user : ALL
              + : ssm-user : ALL
              + : (cluster-admins) : ALL
              - : ALL : ALL
              EOF
              cat << 'EOF' > pam.sh
              #!/bin/bash
              # Pre-req to enforce access control on the /etc/security/access.conf file
              sed -i '2i account required pam_access.so' /etc/pam.d/sshd
              EOF
              chmod +x restrict-access.sh
              chmod +x pam.sh
              aws s3 cp restrict-access.sh s3://${S3BucketName}
              aws s3 cp pam.sh s3://${S3BucketName}
              cd pcluster-installer-bundle
              sudo chmod +x install_pcluster.sh
              sudo bash install_pcluster.sh
              source ~/.bash_profile
              cd /usr/bin/pcluster
              export PATH=/usr/bin/pcluster/pcluster-installer-bundle:$PATH
              export AWS_STS_REGIONAL_ENDPOINTS=regional              
              pcluster create-cluster --cluster-name "IsolatedClusterwithAD" --cluster-configuration "./IsolatedClusterWithAD.yaml" --suppress-validators type:AdditionalIamPolicyValidator --rollback-on-failure false 

  PostRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      Policies:
        - PolicyName: LogOutput
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                - logs:CreateLogGroup
                - logs:CreateLogStream
                - logs:PutLogEvents
                Effect: Allow
                Resource: '*'
        - PolicyName: ResetPassword
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ds:ResetUserPassword
                Resource: !Sub
                  - arn:${AWS::Partition}:ds:${AWS::Region}:${AWS::AccountId}:directory/${DirectoryId}
                  - { DirectoryId: !Ref Directory }

  PostLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: !Sub "${AWS::StackName}: custom resource handler to finish setting up stack after other resources have been created."
      Handler: index.handler
      MemorySize: 128
      Role: !GetAtt PostRole.Arn
      Runtime: python3.9
      Timeout: 300
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          import time
          import cfnresponse
          import boto3
          import logging
          import random
          import string
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          ds = boto3.client("ds")
          ec2 = boto3.client("ec2")

          def create_physical_resource_id():
              alnum = string.ascii_uppercase + string.ascii_lowercase + string.digits
              return ''.join(random.choice(alnum) for _ in range(16))
          
          def redact_keys(event: dict, redactions: set):
              ret = {}
              for k in event.keys():
                  if k in redactions:
                      ret[k] = "[REDACTED]"
                  else:
                      ret[k] = redact_keys(event[k], redactions) if type(event[k]) is dict else event[k] # handle nesting
              return ret
          
          def handler(event, context):
              print(redact_keys(event, {"ReadOnlyPassword", "UserPassword", "ClusterAdminPassword", "AdminPassword"}))
              print( 'boto version {}'.format(boto3.__version__))
              directory_id = event['ResourceProperties']['DirectoryId']
              instance_id = event['ResourceProperties']['AdDomainAdminNode']

              read_only_password = event['ResourceProperties']['ReadOnlyPassword']
              user_name = event['ResourceProperties']['UserName']
              user_password = event['ResourceProperties']['UserPassword']
              cluster_admin_user_name = event['ResourceProperties']['ClusterAdminName']
              cluster_admin_password = event['ResourceProperties']['ClusterAdminPassword']
              admin_password = event['ResourceProperties']['AdminPassword']

              response_data = {}
              reason = None
              response_status = cfnresponse.SUCCESS

              if event['RequestType'] == 'Create':
                  response_data['Message'] = 'Resource creation successful!'
                  physical_resource_id = create_physical_resource_id()
                  ds.reset_user_password(DirectoryId=directory_id, UserName='ReadOnlyUser', NewPassword=read_only_password)
                  ds.reset_user_password(DirectoryId=directory_id, UserName=user_name, NewPassword=user_password)
                  ds.reset_user_password(DirectoryId=directory_id, UserName=cluster_admin_user_name, NewPassword=cluster_admin_password)
                  ds.reset_user_password(DirectoryId=directory_id, UserName='Admin', NewPassword=admin_password)
              else:
                  physical_resource_id = event['PhysicalResourceId']
              cfnresponse.send(event, context, response_status, response_data, physical_resource_id, reason)

  Post:
    Type: Custom::PostLambda
    Properties:
      ServiceToken: !GetAtt PostLambda.Arn
      AdDomainAdminNode: !Ref AdDomainAdminNode
      DirectoryId: !Ref Directory
      UserName: !Ref UserName
      UserPassword: !Ref UserPassword
      ClusterAdminName: !Ref ClusterAdminName
      ClusterAdminPassword: !Ref ClusterAdminPassword
      AdminPassword: !Ref AdminPassword
      ReadOnlyPassword: !Ref ReadOnlyPassword

  PasswordSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Password for Microsoft AD
      Name: !Sub [ "PasswordSecret-${StackIdSuffix}", {StackIdSuffix: !Select [1, !Split ['/', !Ref 'AWS::StackId']]}]
      SecretString: !Ref ReadOnlyPassword

  DomainCertificateSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Domain certificate
      Name: !Sub [ "DomainCertificateSecret-${StackIdSuffix}", { StackIdSuffix: !Select [ 1, !Split [ '/', !Ref 'AWS::StackId' ] ] } ]

  DomainPrivateKeySecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Domain private key
      Name: !Sub [ "DomainPrivateKeySecret-${StackIdSuffix}", { StackIdSuffix: !Select [ 1, !Split [ '/', !Ref 'AWS::StackId' ] ] } ]

  NetworkLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internal
      SubnetMappings:
        - SubnetId: !Ref IsolatedHPCSubnetOne
          PrivateIPv4Address: "10.0.0.100"
        - SubnetId: !Ref IsolatedHPCSubnetTwo
          PrivateIPv4Address: "10.0.1.100"
      Type: network

  NetworkLoadBalancerTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Port: 389
      Protocol: TCP
      VpcId: !Ref PclusterVpc
      HealthCheckEnabled: True
      HealthCheckIntervalSeconds: 10
      HealthCheckPort: 389
      HealthCheckProtocol: TCP
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 3
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 60
      Targets:
        - Id: !Select [0, !GetAtt Prep.DnsIpAddresses]
          Port: 389
        - Id: !Select [1, !GetAtt Prep.DnsIpAddresses]
          Port: 389
      TargetType: ip

  NetworkLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn: Cleanup
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref NetworkLoadBalancerTargetGroup
      LoadBalancerArn: !Ref NetworkLoadBalancer
      Port: '636'
      Protocol: TLS
      SslPolicy: ELBSecurityPolicy-TLS-1-2-2017-01
      Certificates:
        - CertificateArn: !GetAtt DomainCertificateSetup.DomainCertificateArn

  DomainCertificateSetupLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      Policies:
        - PolicyName: LogOutput
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Effect: Allow
                Resource: '*'
        - PolicyName: ManageDomainCertificate
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - iam:UploadServerCertificate
                  - iam:TagServerCertificate
                Resource: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:server-certificate/*
                Condition:
                  StringEquals:
                    aws:RequestTag/StackId: !Sub ${AWS::StackId}
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  - !Ref DomainCertificateSecret
                  - !Ref DomainPrivateKeySecret

  DomainCertificateSetupLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: !Sub "${AWS::StackName}: custom resource handler to import the domain certificate into IAM."
      Handler: index.handler
      MemorySize: 128
      Role: !GetAtt DomainCertificateSetupLambdaRole.Arn
      Runtime: python3.9
      Timeout: 300
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          import time
          import cfnresponse
          import boto3
          import logging
          import random
          import string

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          iam = boto3.client("iam")
          sm = boto3.client("secretsmanager")

          def create_physical_resource_id():
              alnum = string.ascii_uppercase + string.ascii_lowercase + string.digits
              return ''.join(random.choice(alnum) for _ in range(16))

          def import_certificate(certificate_secret_arn, private_key_secret_arn, domain_name, tags):
              logger.info('Reading secrets from Secrets Manager...')
              domain_certificate = sm.get_secret_value(SecretId=certificate_secret_arn)["SecretString"]
              domain_private_key = sm.get_secret_value(SecretId=private_key_secret_arn)["SecretString"]
              logger.info('Importing certificate into IAM...')

              certificate_arn = iam.upload_server_certificate(
                  ServerCertificateName=domain_name,
                  CertificateBody=domain_certificate,
                  PrivateKey=domain_private_key, Tags=tags
              )["ServerCertificateMetadata"]["Arn"]
              return certificate_arn

          def handler(event, context):
              # Delay the start of the function by 30 seconds
              time.sleep(30)

              logger.info(f"Context: {context}")
              logger.info(f"Event: {event}")
              logger.info(f"Boto version: {boto3.__version__}")

              domain_name = event['ResourceProperties']['DomainName']
              certificate_secret_arn = event['ResourceProperties']['DomainCertificateSecretArn']
              private_key_secret_arn = event['ResourceProperties']['DomainPrivateKeySecretArn']
              tags = [{'Key': 'StackId', 'Value': event['StackId']}]

              response_data = {}
              reason = None
              response_status = cfnresponse.SUCCESS

              physical_resource_id = event.get("PhysicalResourceId", create_physical_resource_id())

              try:
                  if event['RequestType'] == 'Create':
                      certificate_arn = import_certificate(certificate_secret_arn, private_key_secret_arn, domain_name, tags)
                      response_data['DomainCertificateArn'] = certificate_arn
                      response_data['Message'] = f"Resource creation successful! IAM certificate imported: {certificate_arn}"
              except Exception as e:
                  response_status = cfnresponse.FAILED
                  reason = str(e)

              cfnresponse.send(event, context, response_status, response_data, physical_resource_id, reason)

  DomainCertificateSetup:
    Type: Custom::DomainCertificateSetupLambda
    DependsOn:
      - Post
    Properties:
      ServiceToken: !GetAtt DomainCertificateSetupLambda.Arn
      DomainName: !Ref DomainName
      DomainCertificateSecretArn: !Ref DomainCertificateSecret
      DomainPrivateKeySecretArn: !Ref DomainPrivateKeySecret

  CleanupLambdaRole:
    Type: AWS::IAM::Role
    DependsOn:
      - DomainCertificateSetup
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      Policies:
        - PolicyName: LogOutput
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Effect: Allow
                Resource: '*'
        - PolicyName: DeleteDomainCertificate
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - iam:DeleteServerCertificate
                Resource: !GetAtt DomainCertificateSetup.DomainCertificateArn

  CleanupLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: !Sub "${AWS::StackName}: custom resource handler to cleanup resources."
      Handler: index.handler
      MemorySize: 128
      Role: !GetAtt CleanupLambdaRole.Arn
      Runtime: python3.9
      Timeout: 900
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          import time
          import cfnresponse
          import boto3
          import logging
          import random
          import string
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          iam = boto3.client("iam")

          def create_physical_resource_id():
            alnum = string.ascii_uppercase + string.ascii_lowercase + string.digits
            return ''.join(random.choice(alnum) for _ in range(16))

          def delete_certificate(domain_name, certificate_arn):
            logger.info(f"Deleting iam certificate {certificate_arn}...")
            max_attempts = 10
            sleep_time = 60
            for attempt in range(1, max_attempts+1):
              try:
                iam.delete_server_certificate(ServerCertificateName=domain_name)
                break
              except iam.exceptions.DeleteConflictException as e:
                logger.info(f"(Attempt {attempt}/{max_attempts}) Cannot delete IAM certificate because it is in use. Retrying in {sleep_time} seconds...")
                if attempt == max_attempts:
                  raise Exception(f"Cannot delete certificate {certificate_arn}: {e}")
                else:
                  time.sleep(sleep_time)

          def handler(event, context):
            logger.info(f"Context: {context}")
            logger.info(f"Event: {event}")
            logger.info(f"Boto version: {boto3.__version__}")

            response_data = {}
            reason = None
            response_status = cfnresponse.SUCCESS

            physical_resource_id = event.get("PhysicalResourceId", create_physical_resource_id())

            try:
              if event['RequestType'] == 'Delete':
                certificate_arn = event['ResourceProperties']['DomainCertificateArn']
                domain_name = event['ResourceProperties']['DomainName']
                delete_certificate(domain_name, certificate_arn)
            except Exception as e:
              response_status = cfnresponse.FAILED
              reason = str(e)
            cfnresponse.send(event, context, response_status, response_data, physical_resource_id, reason)

  Cleanup:
    Type: Custom::CleanupLambda
    DependsOn:
      - DomainCertificateSetup
    Properties:
      ServiceToken: !GetAtt CleanupLambda.Arn
      DomainName: !Ref DomainName
      DomainCertificateArn: !GetAtt DomainCertificateSetup.DomainCertificateArn

  DomainCertificateSecretReadPolicy:
    Type: AWS::IAM::ManagedPolicy
    DependsOn:
      - DomainCertificateSecret
    Properties:
      ManagedPolicyName: !Sub [ "DomainCertificateSecretReadPolicy-${StackIdSuffix}", { StackIdSuffix: !Select [ 1, !Split [ '/', !Ref 'AWS::StackId' ] ] } ]
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - secretsmanager:GetSecretValue
            Resource:
              - !Ref DomainCertificateSecret

Outputs:
  VPCId:
    Description: The ID of the VPC
    Value: !Ref PclusterVpc
  EC2InstanceId:
    Description: The ID of the ParallelCluster Admin Node
    Value: !Ref AdDomainAdminNode
  DomainName:
    Value: !Ref DomainName
  PasswordSecretArn:
    Value: !Ref PasswordSecret
  DomainCertificateArn:
    Value: !GetAtt DomainCertificateSetup.DomainCertificateArn
  DomainCertificateSecretArn:
    Value: !Ref DomainCertificateSecret
  DomainReadOnlyUser:
    Value: !Sub
      - cn=ReadOnlyUser,ou=Users,ou=${ou},dc=${dc}
      - { dc: !Join [",dc=", !Split [".", !Ref DomainName ]], ou: !GetAtt Prep.DomainShortName }
  DomainAddrLdap:
    Value: !Sub
      - ldap://${address}
      - address: !Join [",ldap://", !GetAtt Prep.DnsIpAddresses]
  DomainAddrLdaps:
    Value: !Sub ldaps://${DomainName}
  DomainCertificateSecretReadPolicy:
    Value: !Ref DomainCertificateSecretReadPolicy   