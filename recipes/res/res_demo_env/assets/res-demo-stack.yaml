Description: Research and Engineering Studio on AWS demo environment

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: RES Configuration
        Parameters:
          - EnvironmentName
          - AdministratorEmail
      - Label:
          default: Access Management
        Parameters:
          - Keypair
          - ClientIpCidr
          - InboundPrefixList

Parameters:

  Keypair:
    Description: EC2 Keypair to access management instance.
    Type: AWS::EC2::KeyPair::KeyName
    Default: ""

  EnvironmentName:
    Description: Provide name of the RES Environment. Must be unique for your account and AWS Region.
    Type: String
    Default: res-demo
    MinLength: 5
    MaxLength: 10
    AllowedPattern: ^(?!.*aws)res-[a-z0-9-]{1,6}$
    ConstraintDescription: EnvironmentName must start with "res-", cannot contain "aws", and entire name must be less than or equal to 10 characters (lowercase, numbers, hypens are permitted).

  AdministratorEmail:
    Type: String
    AllowedPattern: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$

  ClientIpCidr:
    Description: Default IP(s) allowed to directly access the Web UI, SSH into the bastion host, and access the Windows AD admin host. We recommend that you restrict it with your own IP/subnet (x.x.x.x/32 for your own ip or x.x.x.x/24 for range. Replace x.x.x.x with your own PUBLIC IP. You can get your public IP using tools such as https://ifconfig.co/)
    Default: 0.0.0.0/0
    Type: String
    AllowedPattern: (\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})
    ConstraintDescription: Value must be a valid IP or network range of the form x.x.x.x/x.

  InboundPrefixList:
    Description: (Optional) VPC Prefix List controlling inbound access to Web UI, bastion host, and Windows AD admin host. 
    Default: ""
    Type: String
    AllowedPattern: ^(pl-[a-z0-9]{8,20})?$
    ConstraintDescription: Must be a valid VPC Prefix List ID, which begins with `pl-` or be empty.

Conditions:
  UseEnvironmentName: !Not [!Equals [!Ref EnvironmentName, ""]]

Resources:

  AdminPassword:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Active Directory Administrator Account Password.
      Name: !Sub [ "res-AdminPassword-${StackName}-${StackId}", {StackName: !Select [1, !Split ['/', !Ref 'AWS::StackId']], StackId: !Select [2, !Split ['/', !Ref 'AWS::StackId']]}]
      GenerateSecretString:
        SecretStringTemplate: '{"username": "Admin"}'
        GenerateStringKey: "password"
        ExcludePunctuation: true
      Tags:
        - Key: res:Deployment
          Value: "true"
        - Key: res:EnvironmentName
          Value: !Ref EnvironmentName

  ServiceAccountPassword:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Active Directory Service Account Password.
      Name: !Sub [ "res-ServiceAccountPassword-${StackName}-${StackId}", {StackName: !Select [1, !Split ['/', !Ref 'AWS::StackId']], StackId: !Select [2, !Split ['/', !Ref 'AWS::StackId']]}]
      GenerateSecretString:
        SecretStringTemplate: '{"username": "ServiceAccount"}'
        GenerateStringKey: "password"
        ExcludePunctuation: true
      Tags:
        - Key: res:Deployment
          Value: "true"
        - Key: res:EnvironmentName
          Value: !Ref EnvironmentName

  RESExternal:
    Type: AWS::CloudFormation::Stack
    Properties:
      Parameters:
        PortalDomainName: ""
        Keypair: !Ref Keypair
        EnvironmentName: !If [UseEnvironmentName, !Ref EnvironmentName, ""]
        AdminPassword: !Ref AdminPassword
        ServiceAccountPassword: !Ref ServiceAccountPassword
        ClientIpCidr: !Ref ClientIpCidr
        ClientPrefixList: !Ref InboundPrefixList
        RetainStorageResources: "False"  
      TemplateURL: https://aws-hpc-recipes.s3.us-east-1.amazonaws.com/main/recipes/res/res_demo_env/assets/bi.yaml

  RES:
    Type: AWS::CloudFormation::Stack
    Properties:
      Parameters:
        EnvironmentName: !Ref EnvironmentName
        AdministratorEmail: !Ref AdministratorEmail
        SSHKeyPair: !Ref Keypair
        ClientIp: !Ref ClientIpCidr
        ClientPrefixList: !Ref InboundPrefixList
        CustomDomainNameforWebApp: ""
        ACMCertificateARNforWebApp: ""
        CustomDomainNameforVDI: ""
        PrivateKeySecretARNforVDI: ""
        CertificateSecretARNforVDI: ""
        DomainTLSCertificateSecretArn: ""
        VpcId: !GetAtt [ RESExternal, Outputs.VpcId ]
        LoadBalancerSubnets: !GetAtt [ RESExternal, Outputs.PublicSubnets ]
        InfrastructureHostSubnets: !GetAtt [ RESExternal, Outputs.PrivateSubnets ]
        VdiSubnets: !GetAtt [ RESExternal, Outputs.PrivateSubnets ]
        IsLoadBalancerInternetFacing: "true"
        ActiveDirectoryName: !GetAtt [ RESExternal, Outputs.ActiveDirectoryName ]
        ADShortName: !GetAtt [ RESExternal, Outputs.ADShortName ]
        LDAPBase: !GetAtt [ RESExternal, Outputs.LDAPBase ]
        LDAPConnectionURI: !GetAtt [ RESExternal, Outputs.LDAPConnectionURI ]
        SudoersGroupName: RESAdministrators
        ServiceAccountUsername: !GetAtt [ RESExternal, Outputs.ServiceAccountUsername ]
        ServiceAccountPasswordSecretArn: !GetAtt [ RESExternal, Outputs.ServiceAccountPasswordSecretArn ]
        UsersOU: !GetAtt [ RESExternal, Outputs.UsersOU ]
        GroupsOU: !GetAtt [ RESExternal, Outputs.GroupsOU ]
        SudoersOU: !GetAtt [ RESExternal, Outputs.SudoersOU ]
        ComputersOU: !GetAtt [ RESExternal, Outputs.ComputersOU ]
        SharedHomeFileSystemId: !GetAtt [ RESExternal, Outputs.SharedHomeFilesystemId ]
        InfrastructureHostAMI: ""
        EnableLdapIDMapping: "True"
        IAMPermissionBoundary: ""
        DisableADJoin: "False"
        ServiceAccountUserDN: !GetAtt [ RESExternal, Outputs.ServiceAccountUserDN ]
      TemplateURL: https://research-engineering-studio-us-east-1.s3.amazonaws.com/releases/latest/ResearchAndEngineeringStudio.template.json

  Keycloak:
    Type: AWS::CloudFormation::Stack
    Properties:
      Parameters:
        Keypair: !Ref Keypair
        ServiceAccountPasswordSecretArn: !GetAtt [ RESExternal, Outputs.ServiceAccountPasswordSecretArn ]
        VpcId: !GetAtt [ RESExternal, Outputs.VpcId ]
        PublicSubnet: !Select [0, !Split [",", !GetAtt RESExternal.Outputs.PublicSubnets]]
        ServiceAccountUserDN: !GetAtt [ RESExternal, Outputs.ServiceAccountUserDN ]
        UsersDN: !GetAtt [ RESExternal, Outputs.LDAPBase ]
        LDAPConnectionURI: !GetAtt [ RESExternal, Outputs.LDAPConnectionURI ]
        CogntioUserPoolId: !Sub ${DataGatherCustomResource.UserPoolId}
        EnvironmentBaseURL: !Sub ${DataGatherCustomResource.LoadBalancerDnsName}
        SAMLRedirectUrl: !Sub ${DataGatherCustomResource.SAMLRedirectUrl}
      TemplateURL: https://aws-hpc-recipes.s3.us-east-1.amazonaws.com/main/recipes/res/res_demo_env/assets/keycloak.yaml

  LoadBalancerLookupFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Runtime: python3.11
      Timeout: 10
      Code:
        ZipFile: |
          import cfnresponse
          import boto3
          
          client = boto3.client("dynamodb")
          
          def handler(event, context):
            try:
              if event.get("RequestType") != "Create":
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                return
            
              table_name = event["ResourceProperties"]["TableName"]
            
              alb_dns_name = client.get_item(
                TableName=table_name,
                Key={"key": {"S": "cluster.load_balancers.external_alb.load_balancer_dns_name"}},
              )
              
              nlb_dns_name = client.get_item(
                TableName=table_name,
                Key={"key": {"S": "vdc.external_nlb.load_balancer_dns_name"}},
              )
              
              response = {
                "ALBDNSName": alb_dns_name["Item"]["value"]["S"],
                "NLBDNSName": nlb_dns_name["Item"]["value"]["S"],
              }
              
              cfnresponse.send(event, context, cfnresponse.SUCCESS, response)
            except Exception as e:
              cfnresponse.send(event, context, cfnresponse.FAILED, {"error": str(e)})
      Role:
        !GetAtt LoadBalancerLookupRole.Arn

  LoadBalancerLookupResource:
    Type: Custom::LoadBalancerLookup
    DependsOn: RES
    Properties:
      ServiceToken: !GetAtt LoadBalancerLookupFunction.Arn
      TableName: !Sub ${EnvironmentName}.cluster-settings

  LoadBalancerLookupRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Policies:
        - PolicyName: LoadBalancerLookupRolePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: !Sub arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:*
              - Effect: Allow
                Action:
                  - "dynamodb:GetItem"
                Resource: !Sub arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${EnvironmentName}.cluster-settings

  KeycloakDataGatherLambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: QueryCognitoAndELBv2
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - elasticloadbalancing:DescribeLoadBalancers
                  - elasticloadbalancing:DescribeTags
                  - cognito-idp:ListUserPools
                Resource: '*'
              - Effect: Allow
                Action:
                  - cognito-idp:DescribeUserPool
                Resource:
                  - !Sub arn:${AWS::Partition}:cognito-idp:${AWS::Region}:${AWS::AccountId}:userpool/${AWS::Region}*
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: '*'

  KeycloakDataGatherHandlerFunction:
    Type: 'AWS::Lambda::Function'
    DependsOn: 
     - RES
     - KeycloakDataGatherLambdaExecutionRole
    Properties:
      Description: 'Keycloak Data Gather Handler'
      FunctionName: !Sub KeycloakDataGatherHandler-${AWS::StackName}
      Timeout: 300 # 5 minutes
      Role: !GetAtt KeycloakDataGatherLambdaExecutionRole.Arn
      Handler: index.handler
      Runtime: python3.11
      Code:
        ZipFile: |
          import os
          import boto3
          import urllib.error
          import urllib.parse
          import urllib.request
          import json
          from typing import Any, Dict, TypedDict, Union
          from itertools import chain
          import boto3
          import botocore.exceptions
          import logging
          from typing import TypedDict
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          class CustomResourceResponse(TypedDict):
            Status: str
            Reason: str
            PhysicalResourceId: str
            StackId: str
            RequestId: str
            LogicalResourceId: str
          
          def send_response(url, response):
            request = urllib.request.Request(
              method="PUT",
              url=url,
              data=json.dumps(response).encode("utf-8"),
            )
            urllib.request.urlopen(request)
          
          def handler(event, _):
            logger.info(f"Received event: {event}")
            request_type = event["RequestType"]
            response_url = event["ResponseURL"]
            response = CustomResourceResponse(
              Status="SUCCESS",
              Reason="SUCCESS",
              PhysicalResourceId=event["LogicalResourceId"],
              StackId=event["StackId"],
              RequestId=event["RequestId"],
              LogicalResourceId=event["LogicalResourceId"],
              Data={}
            )
            if request_type == "Delete":
              send_response(response_url, response)
              return

            cluster_name = os.environ['CLUSTER_NAME']
            region_name = os.environ['AWS_REGION']
            cognito_client = boto3.client("cognito-idp")
            elbv2_client = boto3.client('elbv2')
            TAG_NAME = "res:EnvironmentName"

            def populate_cognito_data(response):
              logger.info(f"Working on getting Cognito details")
              userpool_pagintor = cognito_client.get_paginator("list_user_pools")
              userpool_pages = map(lambda p: p.get("UserPools", []), userpool_pagintor.paginate(MaxResults=50))
              userpool_match_fn = lambda up: up.get("Name", "") == f"{cluster_name}-user-pool" and up.get("Id")
              userpools = filter(userpool_match_fn, chain.from_iterable(userpool_pages))
              for userpool in userpools:
                pool_name = userpool.get("Name")
                pool_id = userpool.get("Id")
                logger.info(f"Processing cognito pool: {pool_name} PoolId: {pool_id}")
                describe_user_pool_result = cognito_client.describe_user_pool(
                  UserPoolId=pool_id
                )
                tags = describe_user_pool_result.get("UserPool", {}).get(
                  "UserPoolTags", {}
                )
                match_fn = lambda tg: tg[0] == TAG_NAME and tg[1] == cluster_name
                if next(filter(match_fn, tags.items()), None):
                  logger.info(f"Found matching tags")
                  domain = describe_user_pool_result['UserPool']['Domain']
                  saml_redirect_url = f'https://{domain}.auth.{region_name}.amazoncognito.com/saml2/idpresponse'
                  response["Data"]["UserPoolId"] = pool_id
                  response["Data"]["SAMLRedirectUrl"] = saml_redirect_url
                  return
                else:
                  logger.info("No matching tags found")

            def populate_alb_dns(response):
              logger.info(f"Working on getting load balancer DNS")
              lb_paginator = elbv2_client.get_paginator("describe_load_balancers")
              lb_pages = map(lambda p: p.get("LoadBalancers", []), lb_paginator.paginate())
              lb_match_fn = lambda lb: lb.get("LoadBalancerName", "") == f"{cluster_name}-external-alb"
              load_balancers = filter(lb_match_fn, chain.from_iterable(lb_pages))
              for load_balancer in load_balancers:
                load_balancer_arn = load_balancer.get("LoadBalancerArn", "")
                load_balancer_name = load_balancer.get("LoadBalancerName", "")
                logger.info(f"Processing load balancer: {load_balancer_name}")
                tag_description = elbv2_client.describe_tags(ResourceArns=[load_balancer_arn]).get('TagDescriptions', [None])[0]
                tags = tag_description.get('Tags', [])
                match_fn = lambda t: t['Key'] == TAG_NAME and t['Value'] == cluster_name
                if next(filter(match_fn, tags), None):
                  logger.info(f"Found matching tags")
                  response["Data"]["LoadBalancerDnsName"] = f'https://{load_balancer["DNSName"]}'
                  return
                else:
                  logger.info("No matching tags found")
                  
            try:
              populate_cognito_data(response)
              populate_alb_dns(response)
              if not response["Data"].get("UserPoolId") or not response["Data"].get("SAMLRedirectUrl") or not response["Data"].get("LoadBalancerDnsName"):
                raise Exception(f"Unable to find matching cognito user pool, SAML redirect URL for the user pool, or load balancer. Response: {response}")
            except Exception as e:
              logger.error(f"Error processing request {e}")
              response["Status"] = "FAILED"
              response["Reason"] = str(e)
            finally:
              logger.info(f"Sending response: {response}")
              send_response(url=response_url, response=response)
      Environment:
        Variables:
          CLUSTER_NAME: !Ref EnvironmentName

  DataGatherCustomResource:
    Type: Custom::KeycloakDataGather
    Properties:
      ServiceToken: !GetAtt KeycloakDataGatherHandlerFunction.Arn
  
  InvokeConfigureSSOLambdaRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: InvokeConfigureSSOLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${EnvironmentName}-configure_sso
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: '*'

  InvokeConfigureSSOHandlerFunction:
    Type: 'AWS::Lambda::Function'
    DependsOn: 
     - InvokeConfigureSSOLambdaRole
     - Keycloak
    Properties:
      Description: 'Invoke RES configure sso function'
      FunctionName: !Sub InvokeConfigureSSOHandlerFunction-${AWS::StackName}
      Timeout: 300 # 5 minutes
      Role: !GetAtt InvokeConfigureSSOLambdaRole.Arn
      Handler: index.handler
      Runtime: python3.11
      Code:
        ZipFile: |
          import os
          import boto3
          import urllib.error
          import urllib.parse
          import urllib.request
          import json
          from typing import Any, Dict, TypedDict, Union

          import boto3
          import botocore.exceptions
          import base64
          import logging
          from typing import TypedDict
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          class CustomResourceResponse(TypedDict):
            Status: str
            Reason: str
            PhysicalResourceId: str
            StackId: str
            RequestId: str
            LogicalResourceId: str
          
          def send_response(url, response):
            request = urllib.request.Request(
              method="PUT",
              url=url,
              data=json.dumps(response).encode("utf-8"),
            )
            urllib.request.urlopen(request)
          
          def handler(event, _):
            logger.info(f"Received event: {event}")

            try:
              request_type = event["RequestType"]
              response_url = event["ResponseURL"]
              response = CustomResourceResponse(
                Status="SUCCESS",
                Reason="SUCCESS",
                PhysicalResourceId=event["LogicalResourceId"],
                StackId=event["StackId"],
                RequestId=event["RequestId"],
                LogicalResourceId=event["LogicalResourceId"],
                Data={}
              )
              if request_type == "Delete":
                send_response(response_url, response)
                return
              lambda_name = os.environ['LAMBDA_NAME']
              region_name = os.environ['AWS_REGION']
              keycloak_url = os.environ['KEYCLOAK_URL']

              #Get SAML metadata string from Keycloak
              saml_metadata_url = f"{keycloak_url}/realms/res/protocol/saml/descriptor"
              logger.info(f"SAML metadata url: {saml_metadata_url}")

              local_filename, headers = urllib.request.urlretrieve(saml_metadata_url)
              saml_metadata = open(local_filename, "r").read()
              saml_metadata_utf8encoded = saml_metadata.encode("utf-8")
              saml_metadata_base64_bytes = base64.b64encode(saml_metadata_utf8encoded)
              saml_metadata_base64_string = saml_metadata_base64_bytes.decode("utf-8")

              #Build payload
              payload = json.dumps({ 
                'configure_sso_request': {
                  'provider_name': 'idc', 
                  'provider_type': 'SAML', 
                  'provider_email_attribute': 'email', 
                  'saml_metadata_file': saml_metadata_base64_string
                }
              })

              #Invoke Lambda
              logger.info(f"Invoking configure_sso lambda with payload : {payload}")
              lambda_client = boto3.client("lambda")
              lambda_response = lambda_client.invoke(
                FunctionName=lambda_name,
                Payload=payload
              )

              logger.info(f"Response from configure_sso lambda: lambda_response")
              if 'FunctionError' in lambda_response:
                response_payload = json.loads(response['Payload'].read())
                if 'errorMessage' in response_payload:
                  raise Exception(response_payload['errorMessage'])
                raise Exception(lambda_response['FunctionError'])
            except Exception as e:
              logger.error(f"Error processing request {e}")
              response["Status"] = "FAILED"
              response["Reason"] = str(e)
            finally:
              logger.info(f"Sending response: {response}")
              send_response(url=response_url, response=response)
      Environment:
        Variables:
          LAMBDA_NAME: !Sub ${EnvironmentName}-configure_sso
          KEYCLOAK_URL: !GetAtt [ Keycloak, Outputs.KeycloakUrl ]

  InvokeConfigureSSOCustomResource:
    Type: Custom::InvokeConfigureSSO
    Properties:
      ServiceToken: !GetAtt InvokeConfigureSSOHandlerFunction.Arn

Outputs:
  KeycloakUrl:
    Description: Keycloak Administrator Url
    Value: !GetAtt [ Keycloak, Outputs.KeycloakUrl ]
  KeycloakAdminPasswordSecretArn:
    Description: Keycloak password for admin user
    Value: !GetAtt [ Keycloak, Outputs.KeycloakAdminPasswordSecretArn ]
  ApplicationUrl:
    Description: RES application Url
    Value: !GetAtt DataGatherCustomResource.LoadBalancerDnsName
